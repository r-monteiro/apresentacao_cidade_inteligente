# -*- coding: utf-8 -*-
"""PROJETO_projeto_integrador_2_2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TbTicNale4RQ65ZgsbNquTnX-MNJDkF0

#PROJETO INTEGRADOR 2 - 2024 - CIDADE INTELIGENTE
#MATEUS NATAN ROES SALGUEIRO
#PAULO ELIAS TAVARES GENEROZO
#RAFAEL AUGUSTO MORAES MONTEIRO
#THOMAS JEFFERSON AMÉRICO
"""

#importando as bibliotecas python.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

from google.colab import drive

# MONTA NO GOOGLE DRIVE.
drive.mount('/content/drive')

# CARREGA O ARQUIVO.
cidades = '/content/drive/MyDrive/projeto_integrador_2_2024/cidade_inteligente.xlsx'
dfcidades = pd.read_excel(cidades)

"""#TRATAMENTO DOS DADOS"""

#exibe o .xlsx e mostra qtde de linhas e colunas.
display(dfcidades)
dfcidades.shape

#exibe a 3 linha df como cabeçalho
dfcidades = pd.read_excel(cidades, header=2)
display(dfcidades)

#exibe primeiras linhas
dfcidades.head()

#exibe ultimas linhas
dfcidades.tail()

#verifica se há valores NaN
dfcidades.isna()

#verifica se há valores null
dfcidades.isnull()

#replace ND (não definido) para NaN (Not a Number).
dfcidades_NAN = dfcidades.replace('ND', np.nan)

#remove as colunas se houver pelo menos 1 valor 'NaN' (Not a Number), para que a análise das cidades seja justa.
dfcidades_ND = dfcidades_NAN.dropna(axis=1, how='any')

display(dfcidades_ND)

#remove coluna 'Econômica', 'Sociocultural', 'Meio Ambiente, 'Capacidades Institucionais' do df
#elas são dispensáveis, só servem como norte para visualização da tabela
remover_col = ['Econômica', 'Sociocultural', 'Meio Ambiente', 'Capacidades Institucionais']
dfcidades_ok = dfcidades_ND.drop(columns=remover_col)

display(dfcidades_ok)

#exibe TODAS as colunas do DF
pd.set_option('display.max_columns', None)
display(dfcidades_ok)

"""#ANÁLISE

À fim de organização, e para ficar melhor no entendimento dos gráficos, as colunas restantes serão separadas por seções:

**1) Economia e Desenvolvimento:**

- PIB per capita do município
- Programas e ações habitacionais
- Qualificação profissional e intermediação de mão de obra
- Acesso a crédito, microcrédito e seguro
- Geração de trabalho e renda no município
- Inclusão produtiva urbana

**2) Infraestrutura Urbana:**

- Assentamentos urbanos precários
- Serviços regulares de transporte de passageiros
- Acessibilidade no transporte público
- Ciclomobilidade na cidade
- Escala de acesso a banda larga fixa
- Escala de acesso a banda larga móvel
- Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G
- Cobertura de fibra ótica
- Leitos hospitalares na rede pública municipal
- Médicos disponíveis na rede pública municipal

**3) Social e Cultural:**

- Rede de influência da cidade
- Ações de educação para comunidades específicas
- Estrutura de equipamentos culturais e esportivos
- Proteção do patrimônio cultural material e imaterial
- Políticas públicas para mulheres
- Inclusão social para grupos específicos

**4) Saúde e Segurança:**

- Índice de risco e proteção à saúde dos nascidos vivos
- Políticas públicas e ações para segurança pública
- Vulnerabilidade a riscos e desastres naturais
- Promoção de inclusão digital
- Proteção e gestão do meio ambiente e áreas verdes do município
"""

colunas_selecionadas = [
    # Economia e Desenvolvimento
    'PIB per capita do município',
    'Programas e ações habitacionais',
    'Qualificação profissional e intermediação de mão de obra',
    'Acesso a crédito, microcrédito e seguro',
    'Geração de trabalho e renda no município',
    'Inclusão produtiva urbana',

    # Infraestrutura Urbana
    'Assentamentos urbanos precários',
    ' Serviços regulares de transporte de passageiros',
    'Acessibilidade no transporte público',
    'Ciclomobilidade na cidade',
    'Escala de acesso a banda larga fixa',
    'Escala de acesso a banda larga móvel',
    'Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G',
    'Cobertura de fibra ótica',
    'Leitos hospitalares na rede pública municipal',
    'Médicos disponíveis na rede pública municipal',

    # Social e Cultural
    'Ações de educação para comunidades específicas',
    'Estrutura de equipamentos culturais e esportivos',
    'Proteção do patrimônio cultural material e imaterial',
    'Políticas públicas para mulheres',
    'Inclusão social para grupos específicos',

    # Saúde e Segurança
    'Índice de risco e proteção à saúde dos nascidos vivos',
    'Políticas públicas e ações para segurança pública',
    'Vulnerabilidade a riscos e desastres naturais',
    'Promoção de inclusão digital',
    'Proteção e gestão do meio ambiente e áreas verdes do município'
]

#substitui ',' por '.' em colunas numéricas
#verifica se há colunas com strings e mostra quais são
for coluna in colunas_selecionadas:
    try:
        if dfcidades_ok[coluna].dtype == 'object':
            dfcidades_ok[coluna] = dfcidades_ok[coluna].str.replace(',', '.').astype(float)
    except ValueError as e:
        print(f"Erro na coluna: {coluna} - {e}")

#na coluna de cobertura de fibra ótica, substitui SIM por 1 e NÃO por 0.
dfcidades_ok['Cobertura de fibra ótica'] = dfcidades_ok['Cobertura de fibra ótica'].replace({'SIM': 1, 'NAO': 0})

#exibe como ficou o dataframe
dfcidades_ok.head()

#fazer o .describe() pra mostrar as estatísticas de cada coluna

print(dfcidades_ok.describe())

#adcionamos 'pesos' para cada coluna.
#0.2 = muito relevante
#0.1 = relevante
#0.05 = não muito relevante


#definindo os pesos para cada categoria
pesos = {
    # Economia e Desenvolvimento
    'PIB per capita do município': 0.2,
    'Programas e ações habitacionais': 0.1,
    'Qualificação profissional e intermediação de mão de obra': 0.1,
    'Acesso a crédito, microcrédito e seguro': 0.05,
    'Geração de trabalho e renda no município': 0.1,
    'Inclusão produtiva urbana': 0.1,

    # Infraestrutura Urbana
    'Assentamentos urbanos precários': 0.05,
    ' Serviços regulares de transporte de passageiros': 0.1,
    'Acessibilidade no transporte público': 0.1,
    'Ciclomobilidade na cidade': 0.05,
    'Escala de acesso a banda larga fixa': 0.2,
    'Escala de acesso a banda larga móvel': 0.2,
    'Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G': 0.2,
    'Cobertura de fibra ótica': 0.2,
    'Leitos hospitalares na rede pública municipal': 0.1,
    'Médicos disponíveis na rede pública municipal': 0.1,

    # Social e Cultural
    'Ações de educação para comunidades específicas': 0.05,
    'Estrutura de equipamentos culturais e esportivos': 0.05,
    'Proteção do patrimônio cultural material e imaterial': 0.05,
    'Políticas públicas para mulheres': 0.05,
    'Inclusão social para grupos específicos': 0.05,

    # Saúde e Segurança
    'Índice de risco e proteção à saúde dos nascidos vivos': 0.05,
    'Políticas públicas e ações para segurança pública': 0.1,
    'Vulnerabilidade a riscos e desastres naturais': 0.05,
    'Promoção de inclusão digital': 0.2,
    'Proteção e gestão do meio ambiente e áreas verdes do município': 0.1
}

#calcula pontuação para cada cidade
dfcidades_ok['Pontuação'] = (dfcidades_ok[list(pesos.keys())] * pd.Series(pesos)).sum(axis=1)

#ordena as cidades pela pontuação em ordem decrescente
dfcidades_ok = dfcidades_ok.sort_values(by='Pontuação', ascending=False)

#precisa carregar o dataframe denovo para exibir a coluna nova 'pontuação'

dfcidades_ok.head()

"""#CIDADE BRASILEIRA MAIS ADEQUADA PARA O PROJETO CIDADE INTELIGENTE"""

#mostra primeiras 10 cidades do ranking
print("Primeiras 10 cidades do ranking:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(dfcidades_ok['Cidade'].head(10), dfcidades_ok['Estado'].head(100), dfcidades_ok['Pontuação'].head(10)), start=1):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

#mostra ultimas 10 cidades do ranking
print("\nÚltimas 10 cidades do ranking:")
ultimas_cidades = dfcidades_ok.tail(10).sort_values(by='Pontuação', ascending=False)
for rank, (cidade, estado, pontuacao) in enumerate(zip(ultimas_cidades['Cidade'], ultimas_cidades['Estado'], ultimas_cidades['Pontuação']), start=len(dfcidades_ok) - 9):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

#a cidade com a maior pontuação será a mais adequada para o projeto de cidade inteligente
cidade_mais_adequada = dfcidades_ok.iloc[0]

#conclusão
print("A cidade brasileira mais adequada para o projeto de cidade inteligente é:", cidade_mais_adequada['Cidade'])

def encontrar_indice_cidade_por_pontuacao(df, nome_cidade):
    try:
        #ordena o DataFrame pela coluna 'Pontuação' em ordem decrescente
        df_ordenado = df.sort_values(by='Pontuação', ascending=False).reset_index(drop=True)

        #localiza o índice da linha da cidade desejada no DataFrame ordenado
        indice = df_ordenado.index[df_ordenado['Cidade'] == nome_cidade].tolist()[0]
        return indice
    except IndexError:
        return f"Cidade '{nome_cidade}' não encontrada no DataFrame."

cidade = input("Digite o nome da cidade: ")

#chama a função para encontrar o índice da cidade no DataFrame ordenado
indice = encontrar_indice_cidade_por_pontuacao(dfcidades_ok, cidade)

print(f"A cidade {cidade} está no índice {indice} do DataFrame ordenado por pontuação.")

"""#DIVISÃO DAS CIDADES MAIS ADEQUADAS PARA O PROJETO CIDADE INTELIGENTE POR REGIÃO DO BRASIL"""

regioes_brasil = {
    'Norte': ['AC', 'AP', 'AM', 'PA', 'RO', 'RR', 'TO'],
    'Nordeste': ['AL', 'BA', 'CE', 'MA', 'PB', 'PE', 'PI', 'RN', 'SE'],
    'Centro-Oeste': ['DF', 'GO', 'MT', 'MS'],
    'Sudeste': ['ES', 'MG', 'RJ', 'SP'],
    'Sul': ['PR', 'RS', 'SC']
}

estado_regiao = {estado: regiao for regiao, estados in regioes_brasil.items() for estado in estados}

#adciona a coluna "Região" ao DataFrame dfcidades_ok
dfcidades_ok['Região'] = dfcidades_ok['Estado'].map(estado_regiao)

#exibe o dataframe com a coluna nova 'região'
dfcidades_ok.head()

"""#NORTE"""

#primeiras 10 cidades do ranking
#filtra
regiao_norte = dfcidades_ok[dfcidades_ok['Região'] == 'Norte']

#ordena
ranking_norte = regiao_norte.sort_values(by='Pontuação', ascending=False)

#exibe
print("Ranking das 10 primeiras cidades da Região Norte:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(ranking_norte['Cidade'].head(10), ranking_norte['Estado'].head(10), ranking_norte['Pontuação'].head(10)), start=1):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

#ultimas 10 cidades do ranking

#exibe
print("Ranking das 10 últimas cidades da Região Norte:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(ranking_norte['Cidade'].tail(10), ranking_norte['Estado'].tail(10), ranking_norte['Pontuação'].tail(10)), start=len(ranking_norte) - 9):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

"""#NORDESTE"""

#primeiras 10 cidades do ranking
#filtra
regiao_nordeste = dfcidades_ok[dfcidades_ok['Região'] == 'Nordeste']

#ordena
ranking_nordeste = regiao_nordeste.sort_values(by='Pontuação', ascending=False)

#exibe
print("Ranking das 10 primeiras cidades da Região Nordeste:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(ranking_nordeste['Cidade'].head(10), ranking_nordeste['Estado'].head(10), ranking_nordeste['Pontuação'].head(10)), start=1):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

#ultimas 10 cidades do ranking

#exibe
print("Ranking das 10 últimas cidades da Região Nordeste:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(ranking_nordeste['Cidade'].tail(10), ranking_nordeste['Estado'].tail(10), ranking_nordeste['Pontuação'].tail(10)), start=len(ranking_nordeste) - 9):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

"""#CENTRO-OESTE"""

#primeiras 10 cidades do ranking
#filtra
regiao_centrooeste = dfcidades_ok[dfcidades_ok['Região'] == 'Centro-Oeste']

#ordena
regiao_centrooeste = regiao_centrooeste.sort_values(by='Pontuação', ascending=False)

#exibe
print("Ranking das 10 primeiras cidades da Região Centro-Oeste:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(regiao_centrooeste['Cidade'].head(10), regiao_centrooeste['Estado'].head(10), regiao_centrooeste['Pontuação'].head(10)), start=1):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

#ultimas 10 cidades do ranking

#exibe
print("Ranking das 10 últimas cidades da Região Centro-oeste:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(regiao_centrooeste['Cidade'].tail(10), regiao_centrooeste['Estado'].tail(10), regiao_centrooeste['Pontuação'].tail(10)), start=len(regiao_centrooeste) - 9):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

"""#SUDESTE"""

#primeiras 10 cidades do ranking
#filtra
regiao_sudeste = dfcidades_ok[dfcidades_ok['Região'] == 'Sudeste']

#ordena
regiao_sudeste = regiao_sudeste.sort_values(by='Pontuação', ascending=False)

#exibe
print("Ranking das 10 primeiras cidades da Região Sudeste:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(regiao_sudeste['Cidade'].head(10), regiao_sudeste['Estado'].head(10), regiao_sudeste['Pontuação'].head(10)), start=1):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

#ultimas 10 cidades do ranking

#exibe
print("Ranking das 10 últimas cidades da Região Sudeste:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(regiao_sudeste['Cidade'].tail(10), regiao_sudeste['Estado'].tail(10), regiao_sudeste['Pontuação'].tail(10)), start=len(regiao_sudeste) - 9):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

"""#SUL"""

#primeiras 10 cidades do ranking
#filtra
regiao_sul = dfcidades_ok[dfcidades_ok['Região'] == 'Sul']

#ordena
regiao_sul = regiao_sul.sort_values(by='Pontuação', ascending=False)

#exibe
print("Ranking das 10 primeiras cidades da Região Sul:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(regiao_sul['Cidade'].head(10), regiao_sul['Estado'].head(10), regiao_sul['Pontuação'].head(10)), start=1):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

#ultimas 10 cidades do ranking

#exibe
print("Ranking das 10 últimas cidades da Região Sul:")
for rank, (cidade, estado, pontuacao) in enumerate(zip(regiao_sul['Cidade'].tail(10), regiao_sul['Estado'].tail(10), regiao_sul['Pontuação'].tail(10)), start=len(regiao_sul) - 9):
    print(f"Rank {rank}: {cidade} ({estado}) - Pontuação: {pontuacao:.2f}")

"""#VISUALIZAÇÃO DOS DADOS (GRÁFICO) DAS 10 PRIMEIRAS CIDADES DO RANKING

- Correlação entre as colunas (heatmap).
"""

#seleciona as colunas selecionadas
df_heatmap = dfcidades_ok[colunas_selecionadas]

#plot heatmap
plt.figure(figsize=(16, 8))
sns.heatmap(df_heatmap.corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Heatmap das Correlações das Colunas')
plt.show()

"""#ECONOMIA E DESENVOLVIMENTO

- PIB per capita do município para cada cidade.
"""

#seleciona as 10 primeiras cidades do ranking
top10 = dfcidades_ok.head(10)

#adiciona o estado ao nome da cidade
top10['Cidade (Estado)'] = top10['Cidade'] + ' (' + top10['Estado'] + ')'

#plot gráfico
plt.style.use('seaborn-bright')
plt.figure(figsize=(10, 5))
plt.bar(top10['Cidade (Estado)'], top10['PIB per capita do município'], edgecolor='black')
plt.xlabel('Cidades (Estado)')
plt.ylabel('PIB per capita')
plt.title('PIB per capita das 10 primeiras cidades')
plt.xticks(rotation=90)
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

#plot gráfico TODAS as cidades
#tende a ser uma função exponencial
plt.figure(figsize=(10, 5))
plt.bar(dfcidades_ok['Cidade'], dfcidades_ok['PIB per capita do município'], color='green')
plt.xlabel('Cidades (Estado)')
plt.ylabel('PIB per capita')
plt.title('Gráfico de todas as cidades')
plt.xticks([])
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""- Geração de trabalho e renda no município para cada cidade.

"""

top10 = dfcidades_ok.head(10)

#plot gráfico dispersão
plt.figure(figsize=(10, 6))
plt.scatter(top10['Cidade'], top10['Geração de trabalho e renda no município'], color='black')
plt.xlabel('Cidades')
plt.ylabel('Geração de trabalho e renda no município')
plt.title('Geração de Trabalho e Renda no Município das 10 primeiras cidades')
plt.xticks(rotation=90)
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

#plot gráfico TODAS as cidades
#boxplot mostra que TODAS as cidades estão contidas entre 0 e 5, e a média é de 3.
plt.figure(figsize=(10, 6))
sns.boxplot(y='Geração de trabalho e renda no município', data=dfcidades_ok, color='skyblue')
plt.ylabel('Geração de trabalho e renda no município')
plt.title('Distribuição da Geração de Trabalho e Renda no Município de TODAS as cidades')
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""- Qualificação profissional e intermediação de mão de obra."""

top10 = dfcidades_ok.head(10)

#plot gráfico
plt.figure(figsize=(12, 6))
plt.bar(top10['Cidade'], top10['Qualificação profissional e intermediação de mão de obra'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades')
plt.ylabel('Qualificação profissional e intermediação de mão de obra')
plt.title('Qualificação Profissional e Intermediação de Mão de Obra das 10 primeiras cidades')
plt.xticks(rotation=90)
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

#os valores são bem parecidos, mas com alguns outliders em zero. Isso fica mais claro quando agt pega as 100 primeiras cidades.

top100 = dfcidades_ok.head(100)

#plot boxplot
plt.figure(figsize=(10, 6))
sns.boxplot(y=top100['Qualificação profissional e intermediação de mão de obra'], color='skyblue')
plt.ylabel('Qualificação profissional e intermediação de mão de obra')
plt.title('Distribuição da Qualificação Profissional e Intermediação de Mão de Obra das 100 primeiras cidades')
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

#o boxplot mostra aqui que entre as 100 primeiras cidades, os valores estão contidos entre 5 e 6, com outliers em 0.

"""#INFRAESTRUTURA URBANA

- Escala de acesso à banda larga FIXA.
"""

top10 = dfcidades_ok.head(10)

#plot gráfico
plt.figure(figsize=(8, 6))
plt.scatter(top10['Cidade'], top10['Escala de acesso a banda larga fixa'], color='skyblue')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Escala de acesso a banda larga FIXA')
plt.title('Relação entre Escala de Acesso à Banda Larga FIXA das 10 Primeiras Cidades')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

cidades = dfcidades_ok['Cidade']
acesso_banda_larga = dfcidades_ok['Escala de acesso a banda larga fixa']

#ajuste da linha de regressão
coeficientes = np.polyfit(range(len(cidades)), acesso_banda_larga, 1)
polinomio = np.poly1d(coeficientes)

#plota gráfico
plt.figure(figsize=(8, 6))
plt.scatter(range(len(cidades)), acesso_banda_larga, color='skyblue', label='Dados')
plt.plot(range(len(cidades)), polinomio(range(len(cidades))), color='red', linestyle='--', label='Regressão Linear')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Escala de acesso a banda larga fixa')
plt.title('Relação entre a Escala de Acesso à Banda Larga Fixa de TODAS as cidades')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks([])
plt.legend()
plt.tight_layout()
plt.show()

"""- Escala de acesso à banda larga MÓVEL.

"""

top10 = dfcidades_ok.head(10)

#plot gráfico
plt.figure(figsize=(8, 6))
plt.scatter(top10['Cidade'], top10['Escala de acesso a banda larga móvel'], color='skyblue')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Escala de acesso a banda larga MÓVEL')
plt.title('Relação entre Escala de Acesso à Banda Larga MÓVEL das 10 Primeiras Cidades')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

cidades = dfcidades_ok['Cidade']
acesso_banda_larga = dfcidades_ok['Escala de acesso a banda larga móvel']

#ajuste da linha de regressão
coeficientes = np.polyfit(range(len(cidades)), acesso_banda_larga, 1)
polinomio = np.poly1d(coeficientes)

#plota gráfico
plt.figure(figsize=(8, 6))
plt.scatter(range(len(cidades)), acesso_banda_larga, color='skyblue', label='Dados')
plt.plot(range(len(cidades)), polinomio(range(len(cidades))), color='red', linestyle='--', label='Regressão Linear')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Escala de acesso a banda larga MÓVEL')
plt.title('Relação entre a Escala de Acesso à Banda Larga MÓVEL de TODAS as cidades')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks([])
plt.legend()
plt.tight_layout()
plt.show()

#no boxplot é possível ver mais claramente onde os valores estão mais contidos, a média, e os outliers.
plt.figure(figsize=(8, 6))
sns.boxplot(y=dfcidades_ok['Escala de acesso a banda larga móvel'], color='skyblue')
plt.ylabel('Escala de acesso a banda larga móvel')
plt.title('Distribuição da Escala de Acesso à Banda Larga Móvel de Todas as Cidades')
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""- Cobertura de acesso a banda larga móvel por tecnologia 3G e 4G."""

#TOP 10
top10 = dfcidades_ok.head(10)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(top10['Cidade'], top10['Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G')
plt.title('Cobertura de Acesso à Banda Larga Móvel por Tecnologias 3G e 4G das 10 primeiras cidades')
plt.xticks(rotation=90)
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

#TOP 50
top50 = dfcidades_ok.head(50)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(top50['Cidade'], top50['Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G')
plt.title('Cobertura de Acesso à Banda Larga Móvel por Tecnologias 3G e 4G das 50 primeiras cidades')
plt.xticks(rotation=90)
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

#10 últimas cidades
tail10 = dfcidades_ok.tail(10)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(tail10['Cidade'], tail10['Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Cobertura de acesso a banda larga móvel por tecnologias 3G e 4G')
plt.title('Cobertura de Acesso à Banda Larga Móvel por Tecnologias 3G e 4G das 10 últimas cidades')
plt.xticks(rotation=90)
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""- Cobertura de fibra ótica.
(Lembrando que 1 = existente / 0 = não existente)
"""

top50 = dfcidades_ok.head(50)

#plot gráfico
plt.figure(figsize=(8, 6))
plt.scatter(top50['Cidade'], top50['Cobertura de fibra ótica'], color='skyblue')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Cobertura de fibra ótica')
plt.title('Relação entre Cobertura de fibra ótica das 50 Primeiras Cidades')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

#há maior incidencia 0 (não há cobertura de fibra ótica) nas cidades finais do ranking.
tail10 = dfcidades_ok.tail(50)

#plot gráfico
plt.figure(figsize=(8, 6))
plt.scatter(tail10['Cidade'], tail10['Cobertura de fibra ótica'], color='skyblue')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Cobertura de fibra ótica')
plt.title('Relação entre Cobertura de fibra ótica das 50 últimas cidades')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

#-------------------------------------
#conta o número total de cidades
total_cidades = len(dfcidades_ok)

#conta o número de cidades com cobertura de fibra ótica (1) e sem cobertura (0)
cobertura_counts = dfcidades_ok['Cobertura de fibra ótica'].value_counts()

#calcula a porcentagem de cidades com cobertura de fibra ótica (1) e sem cobertura (0)
porcentagem_com_cobertura = (cobertura_counts[1] / total_cidades) * 100
porcentagem_sem_cobertura = (cobertura_counts[0] / total_cidades) * 100

#exibe
print()
print("Número de cidades COM cobertura de fibra ótica:", f"{cobertura_counts[1]} ({porcentagem_com_cobertura:.2f}%)")
print("\nNúmero de cidades SEM cobertura de fibra ótica:", f"{cobertura_counts[0]} ({porcentagem_sem_cobertura:.2f}%)")

"""#SOCIAL E CULTURAL

- Inclusão social para grupos específicos.
"""

#não é um parâmetro relativamente importante para o nosso projeto, visto que não há um padrão e os valores são inconsistentes em relação ao ranking das cidades (como observa-se nos dois gráficos abaixo)
top10 = dfcidades_ok.head(10)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(top10['Cidade'], top10['Inclusão social para grupos específicos'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades')
plt.ylabel('Inclusão social para grupos específicos')
plt.title('Inclusão Social para Grupos Específicos das 10 primeiras cidades')
plt.xticks(rotation=90)
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

top50 = dfcidades_ok.head(100)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(top50['Cidade'], top50['Inclusão social para grupos específicos'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades')
plt.ylabel('Inclusão social para grupos específicos')
plt.title('Inclusão Social para Grupos Específicos das 100 primeiras cidades')
plt.xticks([])
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""#SAÚDE E SEGURANÇA

- Promoção de inclusão digital.
"""

top10 = dfcidades_ok.head(10)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(top10['Cidade'], top10['Promoção de inclusão digital'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Promoção de inclusão digital')
plt.title('Promoção de Inclusão Digital nas 10 Primeiras Cidades')
plt.xticks(rotation=90)
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

tail10 = dfcidades_ok.tail(10)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(tail10['Cidade'], tail10['Promoção de inclusão digital'], color='skyblue', edgecolor='black')
plt.xlabel('Cidades (Estado)')
plt.ylabel('Promoção de inclusão digital')
plt.title('Promoção de Inclusão Digital nas 10 últimas cidades')
plt.xticks(rotation=90)
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""- Promoção de inclusão digital versus proteção e gestão do meio ambiente e áreas verdes do município.

O gráfico de dispersão com regressão linear mostra a relação entre duas variáveis: "Promoção de inclusão digital" e "Proteção e gestão do meio ambiente e áreas verdes do município", para as 10 primeiras cidades do conjunto de dados.

Cada ponto no gráfico representa uma cidade, onde a posição do ponto no eixo x indica o nível de promoção de inclusão digital naquela cidade, e a posição no eixo y indica o nível de proteção e gestão do meio ambiente e áreas verdes.

A linha vermelha mostra a linha de regressão linear que melhor se ajusta aos dados. Ela representa a tendência geral dos dados: se está inclinada para cima, indica uma relação positiva entre as variáveis, ou seja, à medida que a promoção de inclusão digital aumenta, a proteção e gestão do meio ambiente também tendem a aumentar. Se estiver inclinada para baixo, indica uma relação negativa.
"""

top10 = dfcidades_ok.head(10)

#plot gráfico
plt.figure(figsize=(8, 6))
sns.regplot(x='Promoção de inclusão digital', y='Proteção e gestão do meio ambiente e áreas verdes do município', data=top10, scatter_kws={'color': 'blue'}, line_kws={'color': 'red'})
plt.xlabel('Promoção de inclusão digital')
plt.ylabel('Proteção e gestão do meio ambiente e áreas verdes')
plt.title('Dispersão com Regressão Linear: Promoção de Inclusão Digital vs. Proteção e Gestão do Meio Ambiente (10 primeiras cidades)')
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""- Políticas públicas e ações para segurança pública.

"""

top10 = dfcidades_ok.head(50)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(top10['Cidade'], top10['Políticas públicas e ações para segurança pública'], color='skyblue')
plt.xlabel('Cidades')
plt.ylabel('Políticas públicas e ações para segurança pública')
plt.title('Políticas Públicas e Ações para Segurança Pública nas 50 Primeiras Cidades')
plt.xticks(rotation=90, ha='right')
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

tail50 = dfcidades_ok.tail(50)

#plot gráfico
plt.figure(figsize=(10, 6))
plt.bar(tail50['Cidade'], tail50['Políticas públicas e ações para segurança pública'], color='skyblue')
plt.xlabel('Cidades')
plt.ylabel('Políticas públicas e ações para segurança pública')
plt.title('Políticas Públicas e Ações para Segurança Pública nas 50 últimas cidades')
plt.xticks(rotation=90, ha='right')
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()